{
  "version": 3,
  "sources": [
    "unknown"
  ],
  "names": [
    "MoveDirection",
    "cc",
    "Enum",
    "NONE",
    "UP",
    "DOWN",
    "LEFT",
    "RIGHT",
    "minTilesCount",
    "mapMoveStep",
    "minMoveValue",
    "Class",
    "extends",
    "Component",
    "properties",
    "_touchStartPos",
    "default",
    "serializable",
    "_touching",
    "floorLayerName",
    "barrierLayerName",
    "objectGroupName",
    "startObjectName",
    "successObjectName",
    "onLoad",
    "self",
    "_player",
    "node",
    "getChildByName",
    "_initPlayer",
    "_turnPlayer",
    "_isMapLoaded",
    "active",
    "eventManager",
    "addListener",
    "event",
    "EventListener",
    "KEYBOARD",
    "onKeyPressed",
    "keyCode",
    "_onKeyPressed",
    "restart",
    "_succeedLayer",
    "_initMapPosition",
    "_curTile",
    "_startTile",
    "_updatePlayerPos",
    "start",
    "err",
    "log",
    "getParent",
    "_tiledMap",
    "getComponent",
    "TiledMap",
    "objectGroup",
    "getObjectGroup",
    "startObj",
    "getObject",
    "endObj",
    "startPos",
    "p",
    "sgNode",
    "x",
    "y",
    "endPos",
    "_layerFloor",
    "getLayer",
    "_layerBarrier",
    "_getTilePos",
    "_endTile",
    "playerTiled",
    "_playerLayers",
    "direction",
    "i",
    "layer",
    "console",
    "directionLayer",
    "setPosition",
    "visibleRect",
    "bottomLeft",
    "pos",
    "getPositionAt",
    "posInPixel",
    "mapSize",
    "getContentSize",
    "tileSize",
    "getTileSize",
    "Math",
    "floor",
    "width",
    "height",
    "newTile",
    "mapMoveDir",
    "KEY",
    "up",
    "down",
    "left",
    "right",
    "_tryMoveToNewTile",
    "getMapSize",
    "getTileGIDAt",
    "_tryMoveMap",
    "pointEqualToPoint",
    "moveDir",
    "mapContentSize",
    "mapPos",
    "getPosition",
    "playerPos",
    "viewSize",
    "size",
    "minDisX",
    "minDisY",
    "disX",
    "disY",
    "newPos",
    "minX",
    "maxX",
    "minY",
    "bottom",
    "maxY"
  ],
  "mappings": "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",
  "file": "unknown",
  "sourcesContent": [
    "var MoveDirection = cc.Enum({\n    NONE: 0,\n    UP: 1,\n    DOWN: 2,\n    LEFT: 3,\n    RIGHT: 4\n});\n\nvar minTilesCount = 2;\nvar mapMoveStep = 1;\nvar minMoveValue = 50;\n\ncc.Class({\n    extends: cc.Component,\n\n    properties: {\n        _touchStartPos: {\n            default: null,\n            serializable: false,\n        },\n        _touching: {\n            default: false,\n            serializable: false,\n        },\n\n        floorLayerName: 'floor',\n        barrierLayerName: 'barrier',\n        objectGroupName: 'players',\n        startObjectName: 'SpawnPoint',\n        successObjectName: 'SuccessPoint'\n    },\n\n    // use this for initialization\n    onLoad: function () {\n        var self = this;\n        self._player = self.node.getChildByName('player');\n        self._initPlayer();\n        self._turnPlayer('back');\n        if (! self._isMapLoaded) {\n            self._player.active = false;\n        }\n\n        // Add keyboard event.\n        cc.eventManager.addListener({\n            event: cc.EventListener.KEYBOARD,\n            onKeyPressed: function(keyCode, event) {\n                self._onKeyPressed(keyCode, event);\n            }\n        }, self.node);\n\n\n\n    },\n\n    restart: function() {\n        this._succeedLayer.active = false;\n        this._initMapPosition();\n        this._curTile = this._startTile;\n        this._updatePlayerPos();\n        this._turnPlayer('back');\n    },\n\n    start: function(err) {\n        cc.log('Game start ...', err);\n        if (err) { return; }\n\n        var self = this;\n\n        // Init the map position\n        self._initMapPosition();\n\n        // Init the succeed layer\n        this._succeedLayer = this.node.getParent().getChildByName('successedLayer');\n        this._succeedLayer.active = false;\n\n        // Init the player position\n        self._tiledMap = self.node.getComponent(cc.TiledMap);\n        cc.log(self._tiledMap);\n        var objectGroup = self._tiledMap.getObjectGroup(self.objectGroupName);\n        cc.log(objectGroup);\n        if (!objectGroup) return;\n\n        // Load start object and end object from tited map.\n        var startObj = objectGroup.getObject(this.startObjectName);\n        var endObj = objectGroup.getObject(this.successObjectName);\n        if (!startObj || !endObj) return;\n\n        // Get start position and end position.\n        var startPos = cc.p(startObj.sgNode.x, startObj.sgNode.y);\n        var endPos = cc.p(endObj.sgNode.x, endObj.sgNode.y);\n\n        // Get floor and barrier.\n        this._layerFloor = this._tiledMap.getLayer(this.floorLayerName);\n        this._layerBarrier = this._tiledMap.getLayer(this.barrierLayerName);\n        if (!this._layerFloor || !this._layerBarrier) return;\n\n        this._curTile = this._startTile = this._getTilePos(startPos);\n        this._endTile = this._getTilePos(endPos);\n        if (this._player) {\n            this._updatePlayerPos();\n            this._player.active = true;\n        }\n\n        this._isMapLoaded = true;\n    },\n\n    _initPlayer: function(err) {\n        var self = this;\n        var playerTiled = self._player.getComponent(cc.TiledMap);\n        self._playerLayers = {};\n        self._playerLayers['back'] = playerTiled.getLayer('back');\n        self._playerLayers['front'] = playerTiled.getLayer('front');\n        self._playerLayers['right'] = playerTiled.getLayer('right');\n        self._playerLayers['left'] = playerTiled.getLayer('left');\n    },\n\n    _turnPlayer: function(direction) {\n        for (var i in this._playerLayers) {\n            var layer = this._playerLayers[i];\n            console.log('===', i, layer);\n            if (layer && layer.node) {\n                layer.node.active = false;\n            }\n        }\n        var directionLayer = this._playerLayers[direction];\n        if (directionLayer && directionLayer.node) {\n            directionLayer.node.active = true;\n            // var animal = directionLayer.node.getComponent(cc.Animation);\n            // cc.log(animal);\n            // if (animal) {\n            //     animal.play();\n            // }\n        }\n    },\n\n    _initMapPosition: function() {\n        this.node.setPosition(cc.visibleRect.bottomLeft);\n    },\n\n    _updatePlayerPos: function() {\n        cc.log(this._curTile, this._curTile.x, this._curTile.y);\n        var pos = this._layerFloor.getPositionAt(this._curTile);\n        this._player.setPosition(pos);\n    },\n\n    _getTilePos: function(posInPixel) {\n        var mapSize = this.node.getContentSize();\n        var tileSize = this._tiledMap.getTileSize();\n        var x = Math.floor(posInPixel.x / tileSize.width);\n        var y = Math.floor((mapSize.height - posInPixel.y) / tileSize.height);\n\n        return cc.p(x, y);\n    },\n\n    _onKeyPressed: function(keyCode, event) {\n        if (!this._isMapLoaded || this._succeedLayer.active) { return; }\n\n        var newTile = cc.p(this._curTile.x, this._curTile.y);\n        var mapMoveDir = MoveDirection.NONE;\n        switch(keyCode) {\n            case cc.KEY.up:\n                newTile.y -= 1;\n                mapMoveDir = MoveDirection.DOWN;\n                this._turnPlayer('back');\n                break;\n            case cc.KEY.down:\n                newTile.y += 1;\n                mapMoveDir = MoveDirection.UP;\n                this._turnPlayer('front');\n                break;\n            case cc.KEY.left:\n                newTile.x -= 1;\n                mapMoveDir = MoveDirection.RIGHT;\n                this._turnPlayer('left');\n                break;\n            case cc.KEY.right:\n                newTile.x += 1;\n                mapMoveDir = MoveDirection.LEFT;\n                this._turnPlayer('right');\n                break;\n            default:\n                return;\n        }\n\n        this._tryMoveToNewTile(newTile, mapMoveDir);\n    },\n\n    _tryMoveToNewTile: function(newTile, mapMoveDir) {\n        var mapSize = this._tiledMap.getMapSize();\n        if (newTile.x < 0 || newTile.x >= mapSize.width) return;\n        if (newTile.y < 0 || newTile.y >= mapSize.height) return;\n\n        // If the newTile position in barrier layer of tited map, don't move.\n        if (this._layerBarrier.getTileGIDAt(newTile)) {\n            cc.log('This way is blocked!');\n            return false;\n        }\n\n        // update the player position\n        this._curTile = newTile;\n        this._updatePlayerPos();\n\n        // move the map if necessary\n        this._tryMoveMap(mapMoveDir);\n\n        // check the player is success or not\n        if (cc.pointEqualToPoint(this._curTile, this._endTile)) {\n            cc.log('succeed');\n            this._succeedLayer.active = true;\n        }\n    },\n\n    _tryMoveMap: function(moveDir) {\n        // get necessary data\n        var mapContentSize = this.node.getContentSize();\n        var mapPos = this.node.getPosition();\n        var playerPos = this._player.getPosition();\n        var viewSize = cc.size(cc.visibleRect.width, cc.visibleRect.height);\n        var tileSize = this._tiledMap.getTileSize();\n        var minDisX = minTilesCount * tileSize.width;\n        var minDisY = minTilesCount * tileSize.height;\n\n        var disX = playerPos.x + mapPos.x;\n        var disY = playerPos.y + mapPos.y;\n        var newPos;\n        switch (moveDir) {\n            case MoveDirection.UP:\n                if (disY < minDisY) {\n                    newPos = cc.p(mapPos.x, mapPos.y + tileSize.height * mapMoveStep);\n                }\n                break;\n            case MoveDirection.DOWN:\n                if (viewSize.height - disY - tileSize.height < minDisY) {\n                    newPos = cc.p(mapPos.x, mapPos.y - tileSize.height * mapMoveStep);\n                }\n                break;\n            case MoveDirection.LEFT:\n                if (viewSize.width - disX - tileSize.width < minDisX) {\n                    newPos = cc.p(mapPos.x - tileSize.width * mapMoveStep, mapPos.y);\n                }\n                break;\n            case MoveDirection.RIGHT:\n                if (disX < minDisX) {\n                    newPos = cc.p(mapPos.x + tileSize.width * mapMoveStep, mapPos.y);\n                }\n                break;\n            default:\n                return;\n        }\n\n        if (newPos) {\n            // calculate the position range of map\n            var minX = viewSize.width - mapContentSize.width - cc.visibleRect.left;\n            var maxX = cc.visibleRect.left.x;\n            var minY = viewSize.height - mapContentSize.height - cc.visibleRect.bottom;\n            var maxY = cc.visibleRect.bottom.y;\n\n            if (newPos.x < minX) newPos.x = minX;\n            if (newPos.x > maxX) newPos.x = maxX;\n            if (newPos.y < minY) newPos.y = minY;\n            if (newPos.y > maxY) newPos.y = maxY;\n\n            if (!cc.pointEqualToPoint(newPos, mapPos)) {\n                cc.log('Move the map to new position: ', newPos);\n                this.node.setPosition(newPos);\n            }\n        }\n    }\n});\n"
  ]
}